local vim = vim

local M = {}

local RuntimeDirectory = {}

function RuntimeDirectory.__index(tbl, key)
  local v = rawget(tbl, key)
  if v then
    return v
  end

  local directory = setmetatable({}, RuntimeDirectory)
  rawset(tbl, key, directory)
  return directory
end

function M.new()
  return setmetatable({}, RuntimeDirectory)
end

local function flatten(target_runtime, parent_parts)
  local list = {}
  for part, runtime in pairs(target_runtime) do
    local parts = vim.deepcopy(parent_parts)
    table.insert(parts, part)

    if type(runtime) == "table" then
      vim.list_extend(list, flatten(runtime, parts))
    else
      table.insert(list, {
        runtime = runtime,
        parts = parts,
      })
    end
  end
  return list
end

local template = [[
-- generated by runtimetable.nvim
local ok, runtimetable = pcall(require, "runtimetable")
if not ok then
  vim.api.nvim_echo({ { "not found runtimetable", "WarningMsg" } }, true, {})
  return
end
runtimetable._call(%q, %s)
]]

local get_content = function(runtime, base_path, parts)
  local typ = type(runtime)
  if typ == "string" then
    return runtime
  end

  local info = debug.getinfo(runtime)
  if info.nups > 0 then
    return template:format(base_path, vim.inspect(parts, { newline = "" }))
  end

  local content
  local path = info.source:sub(2)
  if vim.startswith(info.source, "@") and vim.fn.filereadable(path) == 1 then
    local f = io.open(path, "r")
    content = f:read("*a")
    f:close()
  else
    -- for loadstring
    content = info.source
  end

  local lines = vim.split(content, "\n", { plain = true })

  local first_row = info.linedefined
  local last_row = info.lastlinedefined
  lines = vim.list_slice(lines, first_row + 1, last_row - 1)

  return table.concat(lines, "\n")
end

function M.save(base_path, target_runtime)
  for _, info in ipairs(flatten(target_runtime, {})) do
    local dir_path = table.concat({ base_path, unpack(vim.list_slice(info.parts, 1, #info.parts - 1)) }, "/")
    vim.fn.mkdir(dir_path, "p")

    local path = table.concat({ base_path, unpack(info.parts) }, "/")
    local content = get_content(info.runtime, base_path, info.parts)

    local f = io.open(path, "w")
    f:write(content)
    f:close()
  end
end

return M
